# SQL - Row_Number, Rank, Dense_Rank, NTILE e Rank com Group By

## Introdu√ß√£o
Essas fun√ß√µes s√£o conhecidas como **fun√ß√µes de ranking** no SQL. Elas ajudam a criar uma numera√ß√£o/classifica√ß√£o para registros dentro de conjuntos de resultados, muito √∫til para relat√≥rios, dashboards e an√°lises de dados.

---

## 1. ROW_NUMBER()

Atribui um n√∫mero sequencial √∫nico para cada linha dentro de uma part√≠√ß√£o do conjunto de resultados, baseado na ordena√ß√£o especificada.

```sql
SELECT
    produto_id,
    preco,
    ROW_NUMBER() OVER (ORDER BY preco DESC) AS row_num
FROM produtos;
```

- Cada linha recebe um **n√∫mero √∫nico**.
- Mesmo que tenha empates no valor de `preco`, o n√∫mero segue sequencial.

---

## 2. RANK()

Atribui uma classifica√ß√£o para cada linha dentro da part√≠√ß√£o. **Empates** recebem o **mesmo rank** e o pr√≥ximo rank pula conforme o n√∫mero de empates.

```sql
SELECT
    produto_id,
    preco,
    RANK() OVER (ORDER BY preco DESC) AS rank_num
FROM produtos;
```

**Exemplo**:

| Produto | Preco | Rank |
|--------|------|------|
| A | 100 | 1 |
| B | 100 | 1 |
| C | 90 | 3 |
| D | 80 | 4 |

- Produtos `A` e `B` empatam em 1¬∫ lugar.
- `C` pula para rank 3 (n√£o 2).

---

## 3. DENSE_RANK()

Semelhante ao `RANK()`, mas **n√£o pula n√∫meros** em caso de empates.

```sql
SELECT
    produto_id,
    preco,
    DENSE_RANK() OVER (ORDER BY preco DESC) AS dense_rank_num
FROM produtos;
```

**Exemplo**:

| Produto | Preco | Dense_Rank |
|--------|------|------------|
| A | 100 | 1 |
| B | 100 | 1 |
| C | 90 | 2 |
| D | 80 | 3 |

- `A` e `B` empatam, mas `C` fica em 2¬∫, sem "buracos".

---

## 4. NTILE(N)

Divide as linhas em **N grupos aproximadamente iguais** e atribui um n√∫mero de grupo para cada linha.

```sql
SELECT
    produto_id,
    preco,
    NTILE(4) OVER (ORDER BY preco DESC) AS quartil
FROM produtos;
```

- Com `NTILE(4)`, cria **quartis**.
- √ìtimo para separar dados em percentis ou faixas.

---

## 5. RANK() com GROUP BY

O `GROUP BY` √© usado para **agrupar os dados**, e depois o `RANK()` pode ser aplicado **sobre cada grupo** usando `PARTITION BY`.

```sql
SELECT
    categoria,
    produto_id,
    preco,
    RANK() OVER (PARTITION BY categoria ORDER BY preco DESC) AS rank_categoria
FROM produtos;
```

**Explicando:**
- `PARTITION BY categoria`: reinicia o ranking **para cada categoria**.
- Dentro de cada categoria, ordena pelo `preco DESC`.

**Exemplo**:

| Categoria | Produto | Preco | Rank_Categoria |
|-----------|---------|-------|----------------|
| Eletronico | A | 300 | 1 |
| Eletronico | B | 250 | 2 |
| Moveis | C | 400 | 1 |
| Moveis | D | 350 | 2 |

---

## Resumo R√°pido

| Fun√ß√£o | O que faz |
|------|------------|
| ROW_NUMBER() | Sequencial √∫nico, sem considerar empates |
| RANK() | Classifica, empates recebem mesmo rank e pula n√∫meros |
| DENSE_RANK() | Classifica, empates recebem mesmo rank sem pular n√∫meros |
| NTILE(N) | Divide os dados em N partes |

---

## Dica Final
Sempre que usar essas fun√ß√µes, √© obrigat√≥rio definir o `ORDER BY` dentro do `OVER()`. Sem ele, o SQL n√£o sabe como numerar ou classificar!

---

Se quiser, posso montar um exemplinho pr√°tico para voc√™ testar direto num banco! üöÄ

